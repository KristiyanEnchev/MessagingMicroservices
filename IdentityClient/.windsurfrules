1. Architecture Principles
Enforce Clean Architecture:

Presentation Layer: React components, UI state

Application Layer: Business logic, services, use cases

Domain Layer: Domain models, types, validation

Infrastructure Layer: APIs, Auth, Redux Toolkit Query slices

2. State Management
Use Redux Toolkit (RTK) for global state only.

Prefer React Context or local state for ephemeral/isolated state.

All global API calls via RTK Query.

Co-locate apiSlice.ts with the feature.

Use createSlice, avoid manual reducers unless necessary.

3. Component Design Principles
UI is built from Composable, Atomic Components:

atoms/: Buttons, Inputs, Avatars

molecules/: Forms, Cards, Lists

organisms/: Sections, Layouts, Pages

All components must be:

Pure (no side effects)

Typed with explicit Props interfaces

Self-contained and reusable

Accessible by default (aria, keyboard, etc.)

4. Styling & Animation
Use TailwindCSS for all layout/styling.

No custom CSS files or inline styles allowed.

Use shadcn/ui for prebuilt styled components.

Use Framer Motion for animation, isolated per component.

5. Type Safety
TypeScript is strict mode enforced.

noImplicitAny, strictNullChecks, etc.

No usage of any, as unknown as, or @ts-ignore

Shared types go to:

src/entities/ for domain-wide types

types.ts in each feature

6. API Interaction Rules
All external requests via RTK Query endpoints

Response mapping done via DTO mappers before exposing to UI

Domain models are never polluted with transport logic

No direct use of fetch, axios in components

7. Authentication & Access Control
Global context provides auth state, roles, claims

Pages/components must check access early

Do not render unauthorized sections in the DOM

Use Identity API via RTK Query slice (tokens handled securely)

8. Error Handling
No try/catch in components. Use Result pattern or useErrorBoundary.

Use dedicated ErrorBoundary at app shell and feature level

All errors surfaced via:

Alert banners (UI errors)

Toasts (feedback)

Logging to external service

9. Testing
All components must have:

Unit tests (via Vitest or Jest)

Interaction tests (via Testing Library)

All RTK endpoints tested with mocked API layer

E2E via Playwright or Cypress for major user flows

10. Code Hygiene & Dev Tooling
All code autoformatted via Prettier

Linting via ESLint + TypeScript ESLint plugin

Enforce rules via pre-commit hook (husky + lint-staged)

Enable auto-import sorting

Dead code is deleted, not commented out

11. File Naming & Conventions
Use PascalCase for components

camelCase for variables/functions

.tsx for all component files

Use index.ts only for barrel exports

12. Routing (if used)
Central config file (routes.ts) maps path -> component -> meta

Routes are lazy-loaded per feature (React.lazy + Suspense)

Guarded routes must wrap children in access logic

13. Documentation & Dev Onboarding
All feature folders have README.md explaining:

Feature scope

Structure

API endpoints

Business logic quirks

A global /docs/architecture.md explains the entire app layout

14. Dev Experience
Enable HMR via Vite

Global dev errors surfaced via vite-plugin-checker

Use VSCode workspace settings for uniform formatting

Create VSCode Snippets for repeated templates